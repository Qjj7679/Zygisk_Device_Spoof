项目需求：基于 Zygisk 模块模板的 Android 设备信息伪装模块

项目概述：
开发一个基于 Zygisk 模块模板的 Android 设备信息伪装（Device Spoofing）模块，旨在针对特定 Android 应用（通过包名匹配）修改 android.os.Build 类中的静态字段（如 MODEL、BRAND、DEVICE、MANUFACTURER、PRODUCT），伪造设备信息，以绕过应用对设备型号的检测（如游戏或银行 App 的反作弊机制）。

核心功能：
设备信息伪装：动态修改 android.os.Build 类中的静态字段，使目标应用读取到伪造的设备信息。
包名匹配：根据配置文件中指定的应用包名，针对性地应用伪装。
配置文件支持：通过 JSON 配置文件动态指定目标应用及其伪装信息，支持热重载。
隐身模式：在完成伪装后卸载模块，降低被检测风险。
线程安全：确保配置加载和伪装操作的线程安全。
调试模式：提供可开关的日志输出，便于调试（默认关闭）。

依赖库：
JNI（Java Native Interface）：与 Java 层交互，修改 android.os.Build 字段。
Zygisk API：提供模块加载和钩子机制。
rapidjson：解析 JSON 配置文件。
C++ 标准库：使用 string、fstream、unordered_map、mutex、once_flag 等，用于配置管理和线程安全。

模块信息：
模块 ID：zygisk_device_spoof
作者：Qjj0204
描述：A module used to spoof device info.

配置文件：
路径：/data/adb/modules/<模块ID>/config/config.json
格式：JSON，包含目标应用包名及其伪装的设备信息。
示例：
{
  "apps": [
    {
      "package": "com.example.targetapp",
      "brand": "Google",
      "model": "Pixel 7",
      "manufacturer": "Google",
      "device": "cheetah",
      "product": "cheetah"
    },
    {
      "package": "com.example.targetapp1",
      "brand": "Google",
      "model": "Pixel 7",
      "manufacturer": "Google",
      "device": "cheetah",
      "product": "cheetah"
    }
  ]
}

热重载：在 onload() 阶段优先读取 /data/adb/modules/<模块id>/cache/config_cached.json，加载配置文件cache，自动重新解析。
实现方式：使用 service.sh 脚本作为守护进程，监控配置文件变更，通过 inotify（如果可用）或轮询机制检测修改，并将变更同步到缓存文件 /data/adb/modules/<模块ID>/cache/config_cached.json。模块在加载配置时优先读取缓存文件，提高效率。
service.sh 示例（需根据项目实际情况调整）：

#!/system/bin/sh
MODDIR=${0%/*}
CONFIG="${MODDIR}/config/config.json"
CACHE="${MODDIR}/cache/config_cached.json"
LOG_TAG="ZygiskSpoof"

mkdir -p "$(dirname "${CACHE}")"
chmod 0755 "$(dirname "${CACHE}")"

# initial copy (only if cache missing OR you always want to overwrite)
if [ ! -f "${CACHE}" ] && [ -f "${CONFIG}" ]; then
  cp -f "${CONFIG}" "${CACHE}"
  chmod 0644 "${CACHE}"
  log -t ${LOG_TAG} "service: initial cache created"
fi

# Monitor using inotifywait if available
while true; do
  # Use inotifywait if available; fallback to sleep+stat
  if command -v inotifywait >/dev/null 2>&1; then
    inotifywait -e close_write,modify,moved_to,attrib "${CONFIG}" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
      cp -f "${CONFIG}" "${CACHE}" && chmod 0644 "${CACHE}"
      log -t ${LOG_TAG} "service: cache updated"
    fi
  else
    # fallback: poll every 2 seconds (optimized with mtime check)
    sleep 2
    # OPTIMIZED: Check if CONFIG is newer than CACHE, and exists
    if [ -f "${CONFIG}" ] && { [ ! -f "${CACHE}" ] || [ "${CONFIG}" -nt "${CACHE}" ]; }; then
      if cp -f "${CONFIG}" "${CACHE}"; then
        chmod 0644 "${CACHE}"
        log -t ${LOG_TAG} "service: cache updated"
      else
        log -t ${LOG_TAG} "service: failed to copy config"
      fi
    fi
  fi
done &

关键特性：
线程安全：
使用 std::mutex 保护共享资源（如配置文件加载）。
使用 std::once_flag 确保初始化（如 Build 类加载）只执行一次。
调试模式：
通过 debug_mode 控制日志输出，默认关闭。
隐身模式：
在伪装完成后调用 api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY) 卸载模块，减少被检测风险。
双重伪装：
在 preAppSpecialize 和 postAppSpecialize 两个 Zygisk 钩子中执行伪装，确保覆盖不同时机。

项目结构与主要类：
1. 全局变量和辅助结构
DeviceInfo（结构体）：
存储伪装设备信息，包含字段：brand、device、manufacturer、model、product。
current_info：
当前应用的伪装设备信息，使用 std::mutex 确保线程安全。
JniString（类）：
RAII 包装器，管理 JNI 字符串（自动释放 UTF 字符）。
静态变量：
buildClass、modelField 等：缓存 android.os.Build 类的全局引用和字段 ID。
package_map：std::unordered_map<std::string, DeviceInfo>，键为包名，值为对应的伪装设备信息。
config_path：固定配置文件路径（/data/adb/modules/<模块ID>/config/config.json）。
last_config_mtime：记录配置文件最后修改时间，用于检测变更。

2. SpoofModule 类（继承 zygisk::ModuleBase）
核心类，负责 Zygisk 模块的生命周期管理。
onLoad(zygisk::Api api, JNIEnv env)**：
初始化 api 和 env。
调用 ensureBuildClass() 加载 android.os.Build 类（使用 std::call_once 确保单次执行）。
强制重载配置文件（reloadIfNeeded(true)）。
日志：记录模块加载成功。
onUnload()：
释放 android.os.Build 类的全局引用。
清理其他资源。
preAppSpecialize(zygisk::AppSpecializeArgs args)*：
获取应用包名（args->nice_name）。
如果包名为空或解析失败，卸载模块。
调用 reloadIfNeeded(false) 检查并重载配置。
在 package_map 中查找包名：
找到：设置 current_info，调用 spoofDevice() 执行伪装，设置 should_close = false。
未找到：卸载模块。
最后调用隐身模式卸载模块。
postAppSpecialize(const zygisk::AppSpecializeArgs args)*：
确保 buildClass 已加载。
再次查找包名并执行伪装（冗余检查，防止遗漏）。
卸载模块。

3. 私有方法
ensureBuildClass()：
使用 std::call_once 确保初始化只执行一次。
查找 android.os.Build 类，创建全局引用。
获取静态字段 ID（MODEL、BRAND、DEVICE、MANUFACTURER、PRODUCT）。
异常处理：清除 JNI 异常，记录错误日志。
reloadIfNeeded(bool force = false)：
使用 stat() 检查配置文件修改时间（mtime）。
如果文件未变更且非强制加载，跳过。
打开配置文件，解析 JSON：
遍历 apps 数组，提取每个 package 及其对应的 brand、model、device 等。
填充 package_map。
异常处理：捕获 JSON 解析错误或文件打开失败。
更新 last_config_mtime。
spoofDevice(const DeviceInfo& info)：
检查 buildClass 是否有效。
使用 lambda 函数 setStr 修改每个字段：
调用 NewStringUTF 创建 jstring。
调用 SetStaticObjectField 修改静态字段。
释放本地引用，处理 JNI 异常。
日志：记录伪装的设备型号

工作流程：
模块加载（onLoad）：
初始化 JNI 环境和 android.os.Build 类。
加载配置文件到 package_map。
应用启动（preAppSpecialize）：
获取应用包名，检查是否在 package_map 中。
匹配到配置后，调用 spoofDevice() 修改设备信息。
执行隐身模式，卸载模块。
应用专属化后（postAppSpecialize）：
再次执行伪装（防遗漏）。
卸载模块。

配置热重载：
通过 service.sh 监控配置文件 mtime 变更，同步到缓存文件。
模块在 reloadIfNeeded 中检测变更，重新解析 JSON，更新 package_map。

伪装时机：
通过 Zygisk 钩子在进程 fork 时修改 android.os.Build 的静态字段（只读字段通过 JNI 修改）。

注意事项；
隐身性：模块在完成伪装后通过 DLCLOSE_MODULE_LIBRARY 卸载，减少被检测风险。
异常处理：所有 JNI 操作和 JSON 解析需妥善处理异常，避免崩溃。
性能优化：缓存全局引用（如 buildClass），减少重复查找；使用配置文件缓存加速热重载。
调试支持：debug版本开启日志，release版本关闭日志，LOG TAG：ZygiskDeviceSpoof